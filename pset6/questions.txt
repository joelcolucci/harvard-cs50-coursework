0.  "pneumonoultramicroscopicsilicovolcanoconiosis" is a non-organic (artificial) word. Is considered to be the longest word in the English dictionary. It means “a lung disease caused by inhaling very fine ash and sand dust.”
1.  getrusage returns resource "usage statistics. This is the sum of resources used by the process that calls it. In context of speller.c, it is used to get time information to measure before and after a function call. It can be thought of collecting a timestamp to measure performance of "load" etc.

2.  There are 16 members that are part of a variable of type struct rusage.

3.  When passing a variable into an argument it makes a copy of that argument and modifies the copy of it. This is not optimal when passing a struct into a function because this means the entire struct is copied. This equates to needless use of memory. Not good.

4.  speller.c uses a for loop construct to iterate through the text file (passed in via the command line) and complete a spellcheck. The usage is as follows: “for (int c = fgetc(fp); c != EOF; c = fgetc(fp))”. The initializer of the loop (int c = fgetc(fp))is a call of the fgetc function. This gets the first character of the text file. The loop condition (c != EOF) tells the computer to loop until c (a single character read from the text file) is equal to EOF (end of file). The incrementer is another call to fgetc which will move move the programs focus to the next character in the text file.

The for loop body contains if, else if, else if statements. The initial if condition tests to see if the character currently being read is an alpha character or an apostrophe. If the character meets these conditions it is added to an array called “word”. The variable “index” is then incremented. “index” is used to count how many characters are in the array “word”. The next condition tests the value of “index” to see if the word being read is larger than the maximum length of word permitted. If the word is over the maximum a while loop is used to eat up the rest (of that essentially invalid word) character by character. The “index” variable is then reset to zero. The remaining code in the for loop is part of the big if, else construct so the main for loop iterates.

If the initial if statement reviewed above proves false then an else if statement is evaluated. This else if statement tests to see if the character is alphanumeric. If the character is alphanumeric a while loop is used to eat up the remaining the rest of the string. The variable “index” is that reset to zero and the main for loop iterates

The final condition is another else if statement. This else if statement executes if the variable “index” is greater than zero. This signifies that the array variable “word” contains valid characters and the loop has hit a non-alphanumeric character thus meaning an entire word has been captured. The counter variable “words” is then incremented. Next, the array variable “word” is passed into the function “check”. This will check to see if the word found is within the dictionary. If it is the dictionary, the word is considered to be spelled correctly and true is returned. If it is not in the dictionary it is assumed the word is spelled incorrectly and thus false is returned. Finally if the word is in fact misspelled it is printed to the console and the counter variable “misspellings” is incremented. “index” is reset to zero and the loop iterates to start searching for a word once more.

5.  Relying on fscanf alone would cause issues when the program encounters words with apostrophes. By using fgetc the program can iterate through each character in the word with a condition based on being alpha or an apostrophe. This leads to an accurate index count and removes the need for cluttered conditions to scan an additional time after a break due to an apostrophe.

6.  This adds an additional safety check. Both functions “check” and “load” accept pointers as function arguments. This means that the data stored at the address of the pointer could potentially be accidentally modified or deleted. By declaring these as "consts" two things are achieved. It tells the programmer upon revisiting the code that the data won't be modified within the function and it helps to prevent accidental changes to the data.

7.  I used a hash table with separate chaining. The hash table contains pointers to a struct typedef’d to the name “node”. Each node contains a variable called word and a variable called next. “word” is an array of chars of size LENGTH (constant equating to value of 45) + 1 (space for the string terminating null character). “next” is of type pointer to node. The use of the struct construct allows for linked lists to be built in order to implement the separate chaining strategy to handle collisions from the hash function.

8.  My code ran at .21 seconds.

9.  I increased the size of my hash table from 619 (my birthday June 19... not a good idea) to 2500. I saw the performance improve from .21 seconds to .12! I also tested a size of 4000 and did not see any improvement so I kept with a size of 2500.

10. I had a difficult time trying to come up with ways to improve the time of my code. I noted that "check" absorbed the most time at .07 seconds. I recalled that I could insert into the linked lists (upon collisions) in a sorted fashion. I did not choose to do this because the extra cost of sorted on insert would negate the time potentially saved when checking.
